#!/bin/bash
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ralph-loop - Autonomous Claude Loop Runner
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# A lightweight bash script that runs Claude autonomously through tasks.
# No dependencies beyond bash and the `claude` CLI.
#
# HOW IT WORKS:
#   1. Reads PRD.md to find incomplete ğŸ¤– tasks
#   2. Builds a prompt with context from progress.txt
#   3. Runs Claude with --dangerously-skip-permissions
#   4. Parses output for <promise>COMPLETE</promise> token
#   5. When detected, continues to next task
#   6. Stops when: all ğŸ¤– tasks done, only ğŸ§‘ tasks remain, or max iterations
#
# KEY CONCEPTS:
#   - Completion Token: Claude outputs <promise>COMPLETE</promise> when done
#   - Session Persistence: .ralph-session.json tracks state for crash recovery
#   - Lock Files: .ralph.lock prevents multiple instances, detects stale sessions
#   - Context Injection: Recent progress.txt entries injected into prompts
#
# WHEN TO USE THIS vs ralph-tui:
#   - ralph-loop: Headless/CI, minimal systems, zero dependencies, learning
#   - ralph-tui:  Interactive work, fancy TUI, plugins, notifications
#
# Usage:
#   ralph-loop                    # Run with defaults
#   ralph-loop --max-iterations 5 # Limit iterations
#   ralph-loop --resume           # Resume crashed session
#   ralph-loop --status           # Show session status
#
# Learn more: https://github.com/subsy/ralph-tui (the full-featured version)
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

set -e

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Configuration
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VERSION="2.0.0"
MAX_ITERATIONS=100        # Maximum loop iterations before stopping
RESTART_DELAY=3           # Seconds to wait between iterations
CONTEXT_LINES=20          # Lines of progress.txt to inject into prompt

# CLI Configuration (can be overridden by flags, env vars, or config file)
# Precedence: flags > env > config file > defaults
CLI_BACKEND="${RALPH_CLI:-claude}"  # CLI backend: claude or codex
CLI_MODEL="${RALPH_MODEL:-}"        # Model to use (optional)

# File paths
PRD_FILE="PRD.md"
PROGRESS_FILE="progress.txt"
HANDOFF_FILE="HANDOFF.md"
SESSION_FILE=".ralph-session.json"
LOCK_FILE=".ralph.lock"
LOG_DIR=".ralph-logs"
CONFIG_FILE=".ralph-config.json"

# The magic token that signals task completion
# AI outputs this after finishing a task, and we detect it to continue
COMPLETION_TOKEN="<promise>COMPLETE</promise>"
BLOCKED_TOKEN="<promise>BLOCKED</promise>"

# Terminal colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m'

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Utility Functions
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

log_info()    { echo -e "${BLUE}â„¹${NC} $1"; }
log_success() { echo -e "${GREEN}âœ“${NC} $1"; }
log_warning() { echo -e "${YELLOW}âš ${NC} $1"; }
log_error()   { echo -e "${RED}âœ—${NC} $1"; }

timestamp()       { date '+%Y-%m-%d %H:%M:%S'; }
timestamp_short() { date '+%Y-%m-%d %H:%M'; }

# Check if a process is still running (used for stale lock detection)
is_process_running() {
    kill -0 "$1" 2>/dev/null
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CLI Configuration
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Load CLI configuration from .ralph-config.json if present
# This runs after argument parsing to allow flags to override

load_cli_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        # Only use config file values if not already set by flags/env
        if [[ -z "$CLI_BACKEND_FLAG" ]]; then
            local config_cli
            config_cli=$(grep '"cli"' "$CONFIG_FILE" 2>/dev/null | sed 's/.*: *"\([^"]*\)".*/\1/')
            [[ -n "$config_cli" ]] && CLI_BACKEND="$config_cli"
        fi
        if [[ -z "$CLI_MODEL_FLAG" ]]; then
            local config_model
            config_model=$(grep '"model"' "$CONFIG_FILE" 2>/dev/null | sed 's/.*: *"\([^"]*\)".*/\1/')
            [[ -n "$config_model" ]] && CLI_MODEL="$config_model"
        fi
    fi
}

# Build the CLI command based on the selected backend
get_cli_command() {
    local cmd_args=""

    case "$CLI_BACKEND" in
        claude)
            cmd_args="claude --dangerously-skip-permissions"
            [[ -n "$CLI_MODEL" ]] && cmd_args="$cmd_args --model $CLI_MODEL"
            ;;
        codex)
            cmd_args="codex exec --dangerously-bypass-approvals-and-sandbox"
            [[ -n "$CLI_MODEL" ]] && cmd_args="$cmd_args --model $CLI_MODEL"
            ;;
        *)
            log_error "Unknown CLI backend: $CLI_BACKEND"
            log_info "Supported backends: claude, codex"
            exit 1
            ;;
    esac

    echo "$cmd_args"
}

# Validate CLI backend
validate_cli_backend() {
    case "$CLI_BACKEND" in
        claude|codex) return 0 ;;
        *)
            log_error "Invalid CLI backend: $CLI_BACKEND"
            log_info "Supported backends: claude, codex"
            exit 1
            ;;
    esac
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Session Management
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Sessions enable crash recovery. We store state in .ralph-session.json and
# use .ralph.lock with PID to detect if another instance is running or crashed.

create_session() {
    local session_id
    session_id=$(uuidgen 2>/dev/null || echo "session-$$-$(date +%s)")

    cat > "$SESSION_FILE" << EOF
{
  "sessionId": "$session_id",
  "startedAt": "$(timestamp)",
  "updatedAt": "$(timestamp)",
  "iteration": 0,
  "tasksCompleted": 0,
  "status": "running",
  "workingDir": "$(pwd)",
  "pid": $$
}
EOF

    # Lock file contains PID for stale detection
    cat > "$LOCK_FILE" << EOF
{
  "pid": $$,
  "sessionId": "$session_id",
  "timestamp": "$(timestamp)",
  "hostname": "$(hostname)"
}
EOF

    echo "$session_id"
}

update_session() {
    local field=$1 value=$2
    [[ ! -f "$SESSION_FILE" ]] && return

    # Simple sed-based JSON update (works for our flat structure)
    if [[ "$value" =~ ^[0-9]+$ ]]; then
        sed -i.bak "s/\"$field\": [0-9]*/\"$field\": $value/" "$SESSION_FILE"
    else
        sed -i.bak "s/\"$field\": \"[^\"]*\"/\"$field\": \"$value\"/" "$SESSION_FILE"
    fi
    rm -f "${SESSION_FILE}.bak"

    # Always update timestamp
    sed -i.bak "s/\"updatedAt\": \"[^\"]*\"/\"updatedAt\": \"$(timestamp)\"/" "$SESSION_FILE"
    rm -f "${SESSION_FILE}.bak"
}

get_session_field() {
    [[ -f "$SESSION_FILE" ]] && grep "\"$1\"" "$SESSION_FILE" | sed 's/.*: *"\?\([^",}]*\)"\?.*/\1/'
}

# Returns: 0=stale session, 1=active session (error), 2=no lock (ok to proceed)
check_stale_session() {
    [[ ! -f "$LOCK_FILE" ]] && return 2

    local locked_pid
    locked_pid=$(grep '"pid"' "$LOCK_FILE" | sed 's/.*: *\([0-9]*\).*/\1/')

    if [[ -n "$locked_pid" ]] && ! is_process_running "$locked_pid"; then
        log_warning "Found stale session from crashed process (PID: $locked_pid)"
        return 0  # Stale - can be recovered
    elif [[ -n "$locked_pid" ]]; then
        log_error "Another ralph-loop is already running (PID: $locked_pid)"
        return 1  # Active - cannot proceed
    fi
    return 2  # No lock
}

clean_stale_session() {
    rm -f "$LOCK_FILE"
    log_success "Cleaned stale lock file"
    [[ -f "$SESSION_FILE" ]] && update_session "status" "recovered"
}

end_session() {
    update_session "status" "$1"
    rm -f "$LOCK_FILE"
}

show_session_status() {
    echo -e "\n${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${BOLD}Ralph Session Status${NC}"
    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"

    if [[ ! -f "$SESSION_FILE" ]]; then
        echo -e "${DIM}No active session found${NC}"
        return
    fi

    echo -e "Session ID:  ${BLUE}$(get_session_field sessionId)${NC}"
    echo -e "Status:      ${GREEN}$(get_session_field status)${NC}"
    echo -e "Started:     $(get_session_field startedAt)"
    echo -e "Updated:     $(get_session_field updatedAt)"
    echo -e "Iteration:   $(get_session_field iteration)"
    echo -e "Completed:   $(get_session_field tasksCompleted) tasks"

    if [[ -f "$LOCK_FILE" ]]; then
        local locked_pid
        locked_pid=$(grep '"pid"' "$LOCK_FILE" | sed 's/.*: *\([0-9]*\).*/\1/')
        if is_process_running "$locked_pid"; then
            echo -e "Process:     ${GREEN}Running (PID: $locked_pid)${NC}"
        else
            echo -e "Process:     ${RED}Crashed (PID: $locked_pid)${NC}"
        fi
    fi
    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Task Management
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Tasks are read from PRD.md. We look for markdown checkboxes:
#   - [ ] ğŸ¤– Task for Claude (AI task)
#   - [ ] ğŸ§‘ Task for human (skipped)
#   - [x] Completed task

count_tasks() {
    [[ ! -f "$PRD_FILE" ]] && echo "0 0 0 0" && return

    local incomplete complete ai_incomplete human_incomplete
    incomplete=$(grep -c '^\- \[ \]' "$PRD_FILE" 2>/dev/null || echo "0")
    complete=$(grep -c '^\- \[x\]' "$PRD_FILE" 2>/dev/null || echo "0")
    ai_incomplete=$(grep '^\- \[ \]' "$PRD_FILE" 2>/dev/null | grep -c 'ğŸ¤–' || echo "0")
    human_incomplete=$(grep '^\- \[ \]' "$PRD_FILE" 2>/dev/null | grep -c 'ğŸ§‘' || echo "0")

    echo "$incomplete $complete $ai_incomplete $human_incomplete"
}

get_current_task() {
    [[ ! -f "$PRD_FILE" ]] && return
    # Get first incomplete AI task, strip the checkbox and emoji
    grep '^\- \[ \].*ğŸ¤–' "$PRD_FILE" 2>/dev/null | head -1 | \
        sed 's/^- \[ \] //' | sed 's/ğŸ¤–//' | xargs
}

# Determines if the loop should continue
should_continue() {
    read -r incomplete complete ai_incomplete human_incomplete <<< "$(count_tasks)"

    # No PRD.md yet - continue so Claude can create one
    [[ "$incomplete" == "0" && "$complete" == "0" ]] && return 0

    # All tasks complete
    if [[ "$incomplete" == "0" ]]; then
        log_success "All tasks complete!"
        return 1
    fi

    # No AI tasks remaining (only human tasks left)
    if [[ "$ai_incomplete" == "0" ]]; then
        log_warning "Only human (ğŸ§‘) tasks remaining"
        echo "Check HANDOFF.md for tasks that need your attention."
        return 1
    fi

    return 0
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Context Injection
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# We inject recent progress into the prompt so Claude maintains context
# across iterations without re-reading the entire history.

get_recent_progress() {
    if [[ ! -f "$PROGRESS_FILE" || ! -s "$PROGRESS_FILE" ]]; then
        echo "No previous progress recorded."
        return
    fi
    # Get last N lines, cap at 4KB to avoid prompt bloat
    tail -n "$CONTEXT_LINES" "$PROGRESS_FILE" | head -c 4000
}

build_prompt() {
    local iteration=$1
    local current_task
    current_task=$(get_current_task)
    local recent_progress
    recent_progress=$(get_recent_progress)

    cat << PROMPT_EOF
You are running under ralph-loop (iteration $iteration).

## Current Task
${current_task:-"Check PRD.md for the next task or create one if missing."}

## Recent Progress (Last Few Iterations)
$recent_progress

## Instructions
1. Complete the current task (or the highest-priority ğŸ¤– task in PRD.md)
2. Run tests and type checks - they MUST pass
3. Update PRD.md to mark the task complete (- [x])
4. Append to progress.txt with what you did
5. Commit with a descriptive message
6. Output the completion token: <promise>COMPLETE</promise>

IMPORTANT: You MUST output <promise>COMPLETE</promise> after completing each task.
This signals the orchestrator to continue to the next task.

If you encounter an error you cannot resolve after 3 attempts, explain the issue
and output <promise>BLOCKED</promise> instead.

Begin working on the task now.
PROMPT_EOF
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CLI Execution
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# We run the AI CLI and parse its output in real-time looking for completion tokens.
# Output is displayed AND logged to .ralph-logs/iteration-N.log

run_cli_iteration() {
    local iteration=$1
    local prompt
    prompt=$(build_prompt "$iteration")
    local log_file="$LOG_DIR/iteration-$iteration.log"

    mkdir -p "$LOG_DIR"

    # Clean up any stale marker files from previous iterations
    rm -f "${log_file}.complete" "${log_file}.blocked" "${log_file}.error"

    local cli_name
    cli_name=$(echo "$CLI_BACKEND" | tr '[:lower:]' '[:upper:]')
    echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    echo -e "${MAGENTA}${cli_name} OUTPUT (Iteration $iteration)${NC}"
    echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"

    # Create named pipe for real-time output parsing
    local pipe
    pipe=$(mktemp -u)
    mkfifo "$pipe"

    # Background process reads output, displays it, logs it, and checks for tokens
    (
        while IFS= read -r line; do
            echo "$line"                          # Display
            echo "$line" >> "$log_file"           # Log

            # Check for completion tokens (only if no error detected)
            [[ "$line" == *"$COMPLETION_TOKEN"* ]] && touch "${log_file}.complete"
            [[ "$line" == *"$BLOCKED_TOKEN"* ]] && touch "${log_file}.blocked"

            # Check for API errors (marks iteration as failed)
            [[ "$line" == *'"error":'* ]] && touch "${log_file}.error"
            [[ "$line" == *'ERROR:'* ]] && touch "${log_file}.error"
        done < "$pipe"
    ) &
    local parser_pid=$!

    # Run CLI with prompt via stdin (avoids shell escaping issues)
    local cli_cmd
    cli_cmd=$(get_cli_command)
    set +e
    echo "$prompt" | $cli_cmd > "$pipe" 2>&1
    local exit_code=$?
    set -e

    # Cleanup
    wait $parser_pid 2>/dev/null || true
    rm -f "$pipe"

    echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"

    # Check for API errors first (takes precedence over completion tokens)
    if [[ -f "${log_file}.error" ]]; then
        rm -f "${log_file}.error" "${log_file}.complete" "${log_file}.blocked"
        log_error "API error detected - iteration failed"
        return 1  # Failed due to error
    fi

    # Return result based on token detection
    if [[ -f "${log_file}.complete" ]]; then
        rm -f "${log_file}.complete"
        return 0  # Task completed
    elif [[ -f "${log_file}.blocked" ]]; then
        rm -f "${log_file}.blocked"
        return 2  # Task blocked
    else
        return 1  # No completion token (context exhausted or error)
    fi
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Progress Logging
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

log_iteration() {
    local iteration=$1 status=$2 task=$3
    {
        echo ""
        echo "[$(timestamp_short)] ralph-loop iteration $iteration: $status"
        [[ -n "$task" ]] && echo "- Task: $task"
    } >> "$PROGRESS_FILE"
}

write_handoff() {
    local task=$1 log_file=$2
    {
        echo ""
        echo "## Blocked Task ($(timestamp_short))"
        echo "- Task: $task"
        echo "- See log: $log_file"
    } >> "$HANDOFF_FILE"
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Display Functions
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

show_banner() {
    echo -e "${GREEN}"
    cat << 'BANNER'
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—
  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘
  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘
  â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•     â•šâ•â•  â•šâ•â•
BANNER
    echo -e "${NC}"
    echo -e "  ${DIM}Autonomous AI Loop v$VERSION${NC}"
    echo -e "  ${DIM}CLI: ${CLI_BACKEND}${CLI_MODEL:+ (model: $CLI_MODEL)}${NC}"
    echo -e "  ${DIM}Real-time completion detection enabled${NC}"
    echo ""
}

show_status() {
    local iteration=$1
    read -r incomplete complete ai_incomplete human_incomplete <<< "$(count_tasks)"
    local total=$((incomplete + complete))
    local current_task
    current_task=$(get_current_task)

    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${BOLD}Iteration $iteration${NC} of $MAX_ITERATIONS"
    echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"

    if [[ "$total" -gt 0 ]]; then
        local pct=$((complete * 100 / total))
        echo -e "Progress:    ${GREEN}$complete${NC}/$total tasks ($pct%)"
        echo -e "Remaining:   ${YELLOW}$ai_incomplete${NC} ğŸ¤– tasks, ${BLUE}$human_incomplete${NC} ğŸ§‘ tasks"
    else
        echo -e "Status:      ${YELLOW}No PRD.md found${NC}"
    fi

    [[ -n "$current_task" ]] && echo -e "Current:     ${MAGENTA}$current_task${NC}"

    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
}

show_summary() {
    local session_id=$1
    read -r incomplete complete ai_incomplete human_incomplete <<< "$(count_tasks)"

    echo -e "\n${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${GREEN}${BOLD}Ralph Loop Complete!${NC}"
    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    echo -e "Session:     ${DIM}$session_id${NC}"
    echo -e "Completed:   ${GREEN}$complete${NC} tasks"
    echo -e "Remaining:   ${YELLOW}$incomplete${NC} tasks"
    echo -e "Iterations:  $iteration"

    [[ -f "$HANDOFF_FILE" ]] && echo -e "\n${YELLOW}Check HANDOFF.md for tasks that need human attention.${NC}"

    echo -e "\n${DIM}Logs saved to: $LOG_DIR/${NC}"
    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Signal Handling
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cleanup() {
    echo ""
    log_warning "Interrupted by user"
    log_iteration "$iteration" "interrupted" ""
    end_session "interrupted"

    read -r incomplete complete ai_incomplete human_incomplete <<< "$(count_tasks)"
    echo -e "\nFinal Status:"
    echo -e "  Completed: ${GREEN}$complete${NC} tasks"
    echo -e "  Remaining: ${YELLOW}$incomplete${NC} tasks"
    echo -e "  Iterations: $iteration\n"
    exit 0
}

trap cleanup SIGINT SIGTERM

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Argument Parsing
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

RESUME_MODE=false
CLI_BACKEND_FLAG=""
CLI_MODEL_FLAG=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --max-iterations) MAX_ITERATIONS="$2"; shift 2 ;;
        --delay) RESTART_DELAY="$2"; shift 2 ;;
        --cli|-c)
            CLI_BACKEND="$2"
            CLI_BACKEND_FLAG="$2"
            shift 2
            ;;
        --model|-m)
            CLI_MODEL="$2"
            CLI_MODEL_FLAG="$2"
            shift 2
            ;;
        --resume) RESUME_MODE=true; shift ;;
        --status) show_session_status; exit 0 ;;
        --help|-h)
            cat << HELP
ralph-loop v$VERSION - Autonomous AI Runner

Usage: ralph-loop [options]

Options:
  --cli, -c BACKEND    CLI backend: claude (default) or codex
  --model, -m MODEL    Model to use (e.g., claude-sonnet-4-20250514, gpt-4o)
  --max-iterations N   Maximum iterations (default: 100)
  --delay N            Seconds between restarts (default: 3)
  --resume             Resume a crashed session
  --status             Show current session status
  --help, -h           Show this help

CLI Backends:
  claude  Claude Code CLI (default)
          Uses: claude --dangerously-skip-permissions

  codex   OpenAI Codex CLI
          Uses: codex exec --dangerously-bypass-approvals-and-sandbox

Configuration (precedence: flags > env > .ralph-config.json > defaults):
  Environment: RALPH_CLI, RALPH_MODEL
  File:        .ralph-config.json {"cli": "codex", "model": "gpt-4o"}

Features:
  â€¢ Multi-CLI support (Claude, Codex)
  â€¢ Real-time completion detection (<promise>COMPLETE</promise>)
  â€¢ Session persistence with crash recovery
  â€¢ Cross-iteration context injection
  â€¢ Automatic task progression

The loop continues until:
  â€¢ All ğŸ¤– tasks are complete
  â€¢ Only ğŸ§‘ human tasks remain
  â€¢ Max iterations reached
  â€¢ You press Ctrl+C

Examples:
  ralph-loop                          # Use Claude (default)
  ralph-loop --cli codex              # Use OpenAI Codex
  ralph-loop --cli claude --model claude-sonnet-4-20250514
  RALPH_CLI=codex ralph-loop          # Use env var

For a full-featured TUI, see: rwatch
HELP
            exit 0
            ;;
        *) log_error "Unknown option: $1"; echo "Use --help for usage"; exit 1 ;;
    esac
done

# Load config file (if present) - flags/env take precedence
load_cli_config

# Validate CLI backend
validate_cli_backend

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Main Loop
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

main() {
    show_banner

    # Check prerequisites
    if [[ ! -f "CLAUDE.md" ]]; then
        log_error "CLAUDE.md not found"
        echo "Run 'setup-ralph' first to initialize the ralph workflow."
        exit 1
    fi

    # Check for existing session (disable set -e to capture return code)
    set +e
    check_stale_session
    stale_status=$?
    set -e

    if [[ $stale_status -eq 0 ]]; then
        # Stale session found
        if [[ "$RESUME_MODE" == true ]]; then
            clean_stale_session
            iteration=$(get_session_field iteration)
            session_id=$(get_session_field sessionId)
            log_success "Resuming session $session_id from iteration $iteration"
        else
            log_warning "Found stale session. Use --resume to continue or delete .ralph.lock"
            exit 1
        fi
    elif [[ $stale_status -eq 1 ]]; then
        exit 1  # Another instance running
    else
        session_id=$(create_session)
        iteration=0
        log_success "Started new session: $session_id"
    fi

    # Main loop
    local tasks_completed_this_run=0
    local consecutive_failures=0

    while [[ $iteration -lt $MAX_ITERATIONS ]]; do
        ((iteration++))
        update_session "iteration" "$iteration"

        show_status "$iteration"

        if ! should_continue; then
            break
        fi

        local current_task
        current_task=$(get_current_task)
        log_info "Starting iteration $iteration..."
        log_iteration "$iteration" "started" "$current_task"

        # Run Claude and detect completion
        run_cli_iteration "$iteration"
        local result=$?

        case $result in
            0)  # Completion token detected
                log_success "Task completed! (detected completion token)"
                ((tasks_completed_this_run++))
                update_session "tasksCompleted" "$tasks_completed_this_run"
                consecutive_failures=0
                echo ""
                log_info "Continuing to next task in $RESTART_DELAY seconds..."
                sleep "$RESTART_DELAY"
                ;;
            1)  # No completion token
                ((consecutive_failures++))
                log_warning "Claude stopped without completion token (attempt $consecutive_failures/3)"
                if [[ $consecutive_failures -ge 3 ]]; then
                    log_error "Too many consecutive failures. Stopping."
                    log_iteration "$iteration" "failed" "Too many consecutive failures"
                    break
                fi
                log_info "Restarting in $RESTART_DELAY seconds..."
                sleep "$RESTART_DELAY"
                ;;
            2)  # Blocked token detected
                log_warning "Task blocked! Claude encountered an unresolvable issue."
                log_iteration "$iteration" "blocked" "$current_task"
                write_handoff "$current_task" "$LOG_DIR/iteration-$iteration.log"
                log_info "Documented in HANDOFF.md. Continuing to next task..."
                sleep "$RESTART_DELAY"
                ;;
        esac
        echo ""
    done

    end_session "completed"
    show_summary "$session_id"
}

main
